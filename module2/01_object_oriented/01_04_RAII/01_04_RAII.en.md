# Resource leaks
Imagine you have the following code:

```cpp
void some_function() {
    Car* car = new Car;

    // ...

    if (/* ... */) {
        return;
    }

    // ...

    delete car;
}
```

What is wrong with this code?

---

This is a contrived example, but we have memory for a car being dynamically allocated on the first line and freed on the last line. In between, however, what happens if any of this code throws an exception, or if the conditional evaluates to true and we return from the function before the memory is freed?

The result of either of these is a resource leak, which in this case will lead to the program consuming more and more memory over time until memory is exhausted and programs begin to crash.

Resource leaks are not limited only to memory. There are a variety of exhaustable resources that we must take care to clean up after using.

What are some examples?

---

- **File handles**
- **Mutexes**
- **Semaphores**
- **Network connections**
- **Database connections**
- **Transactions**
  
So how can we avoid brittle code such as the previous example?

# Destructors
A destructor is a special member function of a class that is automatically executed whenever an object of that class goes out of scope or is explicitly deleted. Destructors help in cleaning up resources that were acquired during the object's lifetime.

## Destructor Syntax
The destructor has the same name as the class, but is prefixed with a tilde `~`. It takes no arguments and returns no value.

```cpp
class Resource {
public:
    ~Resource() {
        // ...
    }
};
```

In the following example, the `Resource` class acquires memory during construction and releases it in the destructor:

```cpp
#include <iostream>
#include <memory>

class Resource {
public:
    Resource(size_t size) {
        std::cout << "Resource acquired\n";
        data = new int[size];
    }

    ~Resource() {
        std::cout << "Resource released\n";
        delete[] data;
    }

private:
    int* data;
};

int main() {
    Resource resource;
}
```

What is the expected output of the previous code:

---

```
Resource acquired
Resource released
```

By encapsulating a resource's acquisition and release in a class' constructor and destructor, we can easily manage resources properly and greatly simplify our code.

# Resource Acquisition Is Initialization (RAII)

This practice of binding the lifetime of a resource to the lifetime of an object is so important that it has its own name:
**Resource Acquisition IS Initialization (RAII)**.

In fact, the C++ standard library extensively uses RAII. Here are a few examples:

- **`std::unique_ptr`** is a smart pointer that owns and manages another object and disposes of the object when the `std::unique_ptr` goes out of scope. It's particularly useful for managing memory allocations.
  
    ```cpp
    #include <iostream>
    #include <memory>

    void do_something() {
        std::unique_ptr<int> ptr = std::make_unique<int>(4);
        std::cout << "The value is: " << *ptr << std::endl;
    }

    int main() {
        do_something();
        return 0;
    }
    ```
- **`std::lock_guard`** is a simple RAII wrapper for a basic lock (such as `std::mutex`). It acquires the lock upon construction and releases it upon destruction.
    ```cpp
    #include <iostream>
    #include <mutex>
    #include <jthread>

    std::mutex mtx;

    void print_even(int num) {
        std::lock_guard<std::mutex> lock(mtx);
        for (int i = 0; i < num; i += 2) {
            std::cout << i << std::endl;
        }
    }

    void print_odd(int num) {
        std::lock_guard<std::mutex> lock(mtx);
        for (int i = 1; i < num; i += 2) {
            std::cout << i << std::endl;
        }
    }

    int main() {
        std::jthread t1(print_even, 10);
        std::jthread t2(print_odd, 10);
        return 0;
    }
    ```

- **`std::ofstream`** (output file stream) and **`std::ifstream`** (input file stream) are RAII wrappers for file handles. They automatically close the file when the object goes out of scope.
    ```cpp
    #include <fstream>
    #include <iostream>

    void read_file(std::string_view filename) {
        std::ofstream out_file(filename);
        if (out_file.is_open()) {
            out_file << "Hello, RAII!" << std::endl;
        }
    }

    void write_file(std::string_view filename) {
        std::ifstream in_file(filename);
        if (in_file.is_open()) {
            std::string line;
            while (std::getline(in_file, line)) {
                std::cout << line << std::endl;
            }
        }
    }

    int main() {
        std::string filename = "example.txt";
        read_file(filename);
        write_file(filename);
        return 0;
    }
    ```

- **`std::vector`** is a dynamic array that automatically resizes itself when needed. The elements of a `std::vector` are stored on the heap (dynamically allocated memory), and the `std::vector` itself manages the memory allocation and deallocation for its elements using RAII.

When you're writing code and you find yourself thinking, "I need to remember to release/close/free this resource/file/memory" then it is likely that the code needs a RAII-style class.

# Exercises

## Exercise 1
What is the purpose of a destructor in C++?

```
A. To initialize an object's data members.
B. To allocate memory for an object.
C. To release resources and clean up an object's state before it is destroyed.
D. To perform calculations on an object's data members.
```

---

```
C
```

## Exercise 2
What happens when an object of a class with a destructor goes out of scope?

```
A. The object's constructor is called.
B. The object's destructor is called.
C. Nothing happens.
D. The program crashes.
```

---

```
B
```

## Exercise 3
Which C++ standard library class uses RAII to manage file handles?

```
A. std::iostream
B. std::string
C. std::ofstream
D. std::array
```

---

```
C
```

## Exercise 4
Identify the bug in the following code:

```cpp
class MemoryBlock {
public:
    MemoryBlock(size_t size) : data(new int[size]) {}

private:
    int* data;
};

int main() {
    MemoryBlock block(5);
}
```

---

```
The MemoryBlock class allocates memory in its constructor but does not define a destructor to free the memory. This will cause a memory leak when the object goes out of scope.
```

## Exercise 5

Create a `Timer` class that measures the time elapsed between its construction and destruction. Use the RAII idiom to start the timer when the object is created and stop the timer when the object is destroyed. The class should print the elapsed time in milliseconds when the object is destroyed.

Begin with the following code as a starting point:

```cpp
#include <chrono>

class Timer {
public:
    // TODO
private:
    // TODO
};

int main() {
    Timer timer;
    // TODO
}
```

---

```cpp
#include <iostream>
#include <chrono>

class Timer {
public:
    Timer() {
        start_time = std::chrono::high_resolution_clock::now();
    }

    ~Timer() {
        auto end_time = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time).count();
        std::cout << "Elapsed time: " << duration << " ms" << std::endl;
    }

private:
    std::chrono::high_resolution_clock::time_point start_time;
};

int main() {
    Timer timer;

    for (int i = 0; i < 1'000'000; ++i) {
        int j = i * i;
    }
}
```